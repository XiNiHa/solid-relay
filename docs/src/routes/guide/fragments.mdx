---
title: Fragments
---

# Fragments

Fragments are one of Relay's most powerful features, enabling component composition, data masking, and efficient data fetching. This guide covers how to use fragments effectively in Solid Relay.

## Basic Fragments with createFragment

Use `createFragment` to read fragment data within a component:

```tsx
import { createFragment } from 'solid-relay';
import { graphql } from 'relay-runtime';

const UserProfile_user = graphql`
  fragment UserProfile_user on User {
    id
    name
    email
    avatar
  }
`;

function UserProfile(props: { user: any }) {
  const user = createFragment(UserProfile_user, props.user);

  return (
    <div>
      <img src={user().avatar} alt={user().name} />
      <h2>{user().name}</h2>
      <p>{user().email}</p>
    </div>
  );
}
```

## Fragment Composition

Compose fragments from child components in parent queries:

```tsx
// UserCard.tsx
const UserCard_user = graphql`
  fragment UserCard_user on User {
    id
    name
    avatar
  }
`;

export function UserCard(props: { user: any }) {
  const user = createFragment(UserCard_user, props.user);

  return (
    <div class="user-card">
      <img src={user().avatar} alt={user().name} />
      <span>{user().name}</span>
    </div>
  );
}

// UserList.tsx
import { UserCard } from './UserCard';

const UserListQuery = graphql`
  query UserListQuery {
    users {
      id
      ...UserCard_user  # Compose fragment from UserCard
    }
  }
`;

function UserList() {
  const data = createLazyLoadQuery(UserListQuery, {});

  return (
    <div>
      <For each={data().users}>
        {(user) => <UserCard user={user} />}
      </For>
    </div>
  );
}
```

## Data Masking

Fragments provide data masking, ensuring components only access the data they declare:

```tsx
const UserProfile_user = graphql`
  fragment UserProfile_user on User {
    name
    email
    # This component can't access 'avatar' or other fields
  }
`;

function UserProfile(props: { user: any }) {
  const user = createFragment(UserProfile_user, props.user);

  // ✅ This works - name is in the fragment
  console.log(user().name);

  // ❌ This would cause a TypeScript error - avatar not declared
  // console.log(user().avatar);

  return <div>{user().name}</div>;
}
```

## Refetchable Fragments

Make fragments refetchable to update their data independently:

```tsx
import { createRefetchableFragment } from 'solid-relay';

const UserProfile_user = graphql`
  fragment UserProfile_user on User
  @refetchable(queryName: "UserProfileRefetchQuery") {
    id
    name
    email
    posts(first: 5) {
      edges {
        node {
          id
          title
        }
      }
    }
  }
`;

function UserProfile(props: { user: any }) {
  const [user, refetch] = createRefetchableFragment(UserProfile_user, props.user);

  const handleRefresh = () => {
    refetch({}, { fetchPolicy: 'network-only' });
  };

  const loadMorePosts = () => {
    refetch(
      { first: 10 }, // Fetch more posts
      { fetchPolicy: 'store-and-network' }
    );
  };

  return (
    <div>
      <h2>{user().name}</h2>
      <button onClick={handleRefresh}>Refresh Profile</button>
      <button onClick={loadMorePosts}>Load More Posts</button>

      <div>
        <For each={user().posts.edges}>
          {(edge) => (
            <div>{edge.node.title}</div>
          )}
        </For>
      </div>
    </div>
  );
}
```

## Pagination Fragments

Use pagination fragments for efficient list loading:

```tsx
import { createPaginationFragment } from 'solid-relay';

const UserPosts_user = graphql`
  fragment UserPosts_user on User
  @refetchable(queryName: "UserPostsPaginationQuery") {
    posts(
      first: $count
      after: $cursor
    ) @connection(key: "UserPosts_posts") {
      edges {
        node {
          id
          title
          content
          createdAt
        }
      }
      pageInfo {
        hasNextPage
        endCursor
      }
    }
  }
`;

function UserPosts(props: { user: any }) {
  const [data, { loadNext, isLoadingNext, hasNext }] = createPaginationFragment(
    UserPosts_user,
    props.user
  );

  const handleLoadMore = () => {
    if (hasNext() && !isLoadingNext()) {
      loadNext(10); // Load 10 more items
    }
  };

  return (
    <div>
      <For each={data().posts.edges}>
        {(edge) => (
          <article>
            <h3>{edge.node.title}</h3>
            <p>{edge.node.content}</p>
            <small>{edge.node.createdAt}</small>
          </article>
        )}
      </For>

      <Show when={hasNext()}>
        <button
          onClick={handleLoadMore}
          disabled={isLoadingNext()}
        >
          {isLoadingNext() ? 'Loading...' : 'Load More'}
        </button>
      </Show>
    </div>
  );
}
```

## Conditional Fragments

Use conditional fragments based on GraphQL types:

```tsx
const FeedItem_item = graphql`
  fragment FeedItem_item on FeedItemType {
    __typename
    ... on Post {
      id
      title
      content
      author {
        name
      }
    }
    ... on Comment {
      id
      text
      author {
        name
      }
      post {
        title
      }
    }
  }
`;

function FeedItem(props: { item: any }) {
  const item = createFragment(FeedItem_item, props.item);

  return (
    <Switch>
      <Match when={item().__typename === 'Post'}>
        <PostItem post={item()} />
      </Match>
      <Match when={item().__typename === 'Comment'}>
        <CommentItem comment={item()} />
      </Match>
    </Switch>
  );
}
```

## Fragment Variables

Pass variables to fragments for dynamic behavior:

```tsx
const UserPosts_user = graphql`
  fragment UserPosts_user on User
  @argumentDefinitions(
    count: { type: "Int", defaultValue: 5 }
    includeContent: { type: "Boolean", defaultValue: false }
  ) {
    posts(first: $count) {
      edges {
        node {
          id
          title
          content @include(if: $includeContent)
        }
      }
    }
  }
`;

// Usage in parent query
const UserQuery = graphql`
  query UserQuery($userId: ID!, $showContent: Boolean!) {
    user(id: $userId) {
      ...UserPosts_user @arguments(
        count: 10
        includeContent: $showContent
      )
    }
  }
`;
```

## Best Practices

### 1. Colocate Fragments with Components

Keep fragments close to the components that use them:

```tsx
// UserProfile.tsx
const UserProfile_user = graphql`
  fragment UserProfile_user on User {
    # fragment definition
  }
`;

export function UserProfile(props: { user: any }) {
  // component implementation
}
```

### 2. Use Descriptive Fragment Names

Follow the naming convention `ComponentName_propName`:

```tsx
// ✅ Good
const UserProfile_user = graphql`
  fragment UserProfile_user on User { ... }
`;

// ❌ Bad
const UserFragment = graphql`
  fragment UserFragment on User { ... }
`;
```

### 3. Compose Fragments Hierarchically

Build complex UIs by composing fragments from child components:

```tsx
const UserPage_user = graphql`
  fragment UserPage_user on User {
    ...UserProfile_user
    ...UserPosts_user
    ...UserFriends_user
  }
`;
```

### 4. Use TypeScript for Type Safety

Import generated types for better development experience:

```tsx
import type { UserProfile_user$key } from './__generated__/UserProfile_user.graphql';

function UserProfile(props: { user: UserProfile_user$key }) {
  const user = createFragment(UserProfile_user, props.user);
  // TypeScript knows the exact shape of user()
}
```

### 5. Prefer Fragments Over Inline Fields

Use fragments even for simple cases to improve maintainability:

```tsx
// ✅ Good - using fragment
const UserName_user = graphql`
  fragment UserName_user on User {
    name
  }
`;

// ❌ Avoid - inline fields in queries
const SomeQuery = graphql`
  query SomeQuery {
    user {
      name  # Better to use fragment
    }
  }
`;
```

## Next Steps

- [Mutations](/guide/mutations) - Handle data modifications
- [Pagination](/guide/pagination) - Implement efficient list pagination
- [Subscriptions](/guide/subscriptions) - Work with real-time data
